i̇nsanlar hayatın tanımı konusunda tartışıyorlar .
tanımın içinde üreme , metabolizma ya da evrim geçmeli mi sorusuna cevap arıyorlar .
buna verilecek cevabı bende bilmiyorum , o yüzden size söyleyemeyeceğim .
ben hayatın hesaplamayı içerdiğini söyleyeceğim .
bu bir bilgisayar programı .
bir hücreye yüklendiğinde , bu program çalışır ve sonuçta bu kişi oluşabilir , ya da küçük bir _UNK_ , bu kişiye oluşabilir -- başka bir değişiklik -- ve bu kişi ya da büyük bir değişiklik , bu köpek ya da bu ağaç , ya da balina oluşabilir .
şimdi , eğer bu _UNK_ ilgili benzetmeyi ciddiye alırsanız , chris _UNK_ bir bilgisayar üretimi hata olduğunu söyleyebilirsiniz , aynı jim watson , craig venter , veya bizler gibi .
ve kendinizi bu benzetmenin doğru olduğuna inandırmak için , genetik programlar ve bilgisayar _UNK_ arasında sizi ikna edecek bir sürü benzerlik bulabilirsiniz .
ama bana göre en ilgi çekici olan küçük değişikliklere bu kendine özgü _UNK_ ve bu hassaslığın son aşamada büyük biyolojik _UNK_ neden olması .
küçük bir mutasyon , iki kanatlı bir canlıyı alıp , onu dört kanatlı bir canlıya dönüştürebilir .
ya da bu canlıyı alıp bacaklarını , _UNK_ olması gereken yere koyabilir .
ya da eğer " the _UNK_ _UNK_ " ' ı izlediyseniz , oradaki gibi altı parmaklı bir adam da yaratabilir .
şimdi , bilgisayar programlarının en başta gelen özelliği bu tip ufak değişikliklere olan _UNK_ .
eğer bir dolarlık banka _UNK_ alır ve bir _UNK_ kısmını değiştirirseniz 1000 dolarınız olabilir .
bence , bu ufak değişiklikler bize bu artırılmış büyük değişikliklerin altında gelişmekte olan karmaşık bir hesaplama olduğunu gösteriyor .
bütün bunlar , _UNK_ temelinde yatan moleküler programlar olduğunu , biyolojinin bu moleküler programların gücünü _UNK_ işaret ediyor .
benim istediğim şey ise teknoloji üretme _UNK_ olan moleküler programlar yazmak .
bunu yapan pekçok kişi var , craig venter gibi pekçok sentetik biyolog bunu yapıyor ,
onlar hücreleri kullanma konusuna yoğunlaşmış durumdalar .
hücre - _UNK_ .
ben ve arkadaşlarım ise daha çok biyo - moleküler bir merkezli görüşe sahibiz .
bizler dna , rna ve proteinlerle ilgileniyoruz ve en temel yapı taşından birşeyler üretmek için yeni bir dil üretiyoruz , biz biyo - moleküller kullanıyoruz .
bu gördükleriniz bir hücrenin içindeki makinalar .
bu bir kamera .
bunlar hücrenin güneş panelleri , _UNK_ açıp _UNK_ bazı düğmeler , hücrelerin kirişleri , kaslarınızı hareket ettiren motorlar .
benim bir grup moleküler _UNK_ tüm bu yapıları tamamen dna kullanarak yeniden üretmeye çalışıyor .
dna fanatiği değiliz , ama dna bunu yapmak için en ucuz , en kolay anlaşılır ve en kolay programlanabilir şey .
zaman içinde diğer maddelerin kullanımı _UNK_ -- mesela proteinin -- onlarla da çalışabiliriz .
eğer başarılı olursak , moleküler programlama neye _UNK_ ?
bilgisayarınızın başına oturacaksınız .
bir cep telefonu _UNK_ , yüksek * seviyeli bir dil ile o cep telefonunu _UNK_ .
daha sonra bu tanımı bir derleyiciye vereceksiniz ve o da bu tanımı gerçek moleküllere çevirecek , bu moleküller bir sentezleyiciye _UNK_ ve bu sentezleyici o molekülleri bir tohuma yerleştirecek .
eğer bu tohumu düzgün _UNK_ ve bakarsanız , gelişimsel bir hesaplama , bir moleküler hesaplama yapacak , ve elektronik bir bilgisayar _UNK_ .
henüz _UNK_ açık _UNK_ şimdi edeyim , bence yaşam moleküler bilgisayarların elektrokimyasal bilgisayarlar kurması ve bunların elektronik bilgisayarlar kurması ve bunların hep birlikte elektrokimyasal bilgisayarlar kurması , ve onların yeni moleküler bilgisayarlar kurması ve onların da yeni elektronik bilgisayarlar kurmasından ibaret . böyle gidiyor .
ve eğer bunlara inanacak olursanız , yani tüm yaşamın bir nevi hesaplama olduğuna inanıyorsanız , ki ben inanıyorum , büyük sorulara bir bilgisayar bilimcinin gözüyle bakabilirsiniz .
en büyük sorulardan biri , bir bebek büyümesinin durması gerektiği zamanı nasıl bilir ?
bir moleküler programcı için , bu soru cep telefonunuz ne zaman büyümesi gerektiğini nasıl bilir ? şeklinde .
ya da bir bilgisayar programı ne zaman durması gerektiğini nasıl bilir ?
ya da daha konuya yakın olması için , bir programın bir gün duracağını nasıl bilirsiniz ?
buna benzer başka sorular da var .
bunlardan biri craig venter'in sorduğu bir soru .
öyle görünüyor ki o aslında bir bilgisayar bilimci .
sorusu şu : i̇şlevsel bir mikro - organizma ortaya çıkaracak en küçük genomun büyüklüğü nedir ?
en az kaç gen kullanabilirim ?
bu soru , aynen şunun eşdeğeri , microsoft _UNK_ birebir aynısı gibi çalışacak _UNK_ en küçük bilgisayar programı nedir ?
ve bunu yazarken , biliyorsunuz , bakteriler daha da _UNK_ , çalışacak genomlar yazıyor , biz de microsft _UNK_ yaptığını yapabilen daha küşük programlar yazabiliriz .
ama moleküler programlama için , sorumuz şu , bu tohumu cep _UNK_ yerleştirmek için kaç moleküle ihtiyacımız var ?
elde edebileceğimiz en küşük rakam hangisi ?
bunlar , bilgisayar bilimlerinde ciddi sorular .
tamam karmaşıklık sorunları ve bilgisayar bilimi , bize bunların zor sorular olduğunu söylüyor .
hemen hemen tamamını imkansız .
ama bazı görevler için cevap vermeye başlayabiliriz .
bu nedenle , birazdan bahsedeceğim dna yapıları için bu soruları sormaya başlamak istiyorum .
bu normal bir dna , ya da normal dna olarak düşündüğünüz yapı .
çift iplikçikli , çift sarmallı . üzerinde iki ipliği bir arada tutan a'lar , _UNK_ , c'ler ve g'ler var .
bunu sizi fazla _UNK_ için bazen şu şekilde çizeceğim .
biz çift _UNK_ _UNK_ , _UNK_ tek te bakmak istiyoruz .
bunu _UNK_ , önce tek iplikçik geliyor , böylece bir _UNK_ mavi _UNK_ diper tüpte yaptığımız turuncu iplikçiği alıyoruz , tek başlarına dururken daha esnekler .
i̇kisini karıştırıyoruz , ve daha az esnek çift sarmal oluşturuyorlar .
son 25 yıldır _UNK_ _UNK_ ve bir grup takipçisi çok çalıştılar ve bu tip tek dna _UNK_ bir araya gelmesi reaksiyonunu kullanarak bir grup harika _UNK_ yapılar oluşturdular .
ama pek çok yaklaşımları , çok mükemmel de olsa epey zaman aldı .
bu birkaç yıl sürebilir , ya da tasarlaması çok zor olabilir .
bu nedenle ben birkaç yıl önce yeni bir metod buldum . buna dna origamisi diyorum , yapması o kadar basit ki , evde mutfağınızda bile yapabilirsiniz , tasarımları da dizüstü bilgisayarınızda .
ama bunu yapmak için uzun bir tek dna _UNK_ ihtiyaç var , ve bunu elde temek teknik olarak epey zor .
bu nedenle doğal bir kaynağa gidebilirsiniz .
bu bilgisayar - tasarımı _UNK_ bakabilirsiniz , ama onun çift sarmallı genomu var , bu işinize yaramaz .
_UNK_ bakarsınız . orada milyarlarca bakteri var .
onlar da işe yaramaz .
onlar da çift sarmallı . ama onların içinde , onları enfekte eden bir virüs var bu virüs bir parça kağıt gibi _UNK_ güzel , uzun ve tek iplikçikli bir genoma sahip .
işte böyle yapıyoruz .
burası genom .
buna bir sürü kısa sentetik dna ekliyoruz , ben bunlara zımba ismini verdim .
her birinin sol tarafı uzun zincire bir noktadan tutunuyor , sağ tarafı da başka bir yerinden _UNK_ be uzun _UNK_ bu şekilde bir araya topluyorlar .
bu zımbaların ortaya çıkardığı net hareket bu uzun zinciri bir dikdörtgen şeklinde katlamak .
bu sürecin filmini çekmemiz olası değil , ama harvard'dan shawn douglas bizim için hoş bir animasyon yaptı uzun tek _UNK_ ve baz ufak kısa _UNK_ başlıyor .
ve bunları _UNK_ ne olacağını gösteriyor .
biraz ısıtıyoruz , biraz tuz ekliyoruz , neredeyse kaynama noktasında yaklaştırıp tekrar soğutuyoruz , ve _UNK_ kısa zincirler uzun zincire bağlanıyor ve bir yapı oluşturmaya başlıyor
şurada oluşmaya başlayan çift sarmalı görebilirsiniz .
dna _UNK_ baktığınızda , aslında ne olduğunu görebilirsiniz , her ne kadar karmaşık olduğunu düşünseniz de , aslında birbirine paralel bir grup çift _UNK_ oluşuyor kısa zincirlerin bir sarmal boyunca gidip ve sonra bir başka noktaya atlaması sayesinde bir arada tutunuyorlar .
i̇şte burada bir iplikçik var , böyle gidiyor , sarmal boyunca ve bağlanıyor -- sonra sıçrıyor ve başka bir sarmal _UNK_ , sonra geri geliyor
uzun zinciri bu şekilde tutuyor .
size herhangi bir şekilde bunu yapabileceğimizi göstermek istedik , bu nedenle bu şekli yapmaya çalıştım .
dna'yı gözün üzerine katlanacak , _UNK_ aşağıya inecek kenarından dolanacak , alına çıkacak ve sonra tekrar aşağıya inecek ve bit halka oluşturacak şekilde katlamak istedim .
düşündüm ki , bu olursa , her şey yapılabilir .
bu nedenle bilgisayar programına buna benzer kısa _UNK_ _UNK_ .
bunları ısmarladım , fedex ile bana geldiler .
karıştırdım , ısıttım ve tekrar _UNK_ , böylece 50 milyar _UNK_ sahibi oldum . hepsi bi damla su içinde yüzüyorlar .
ve her biri insan saç telinin binde biri genişliğinde , tamam mı ?
i̇şte , hepsi bu sıvının içinde yüzüyorlar , onlara bakmak için _UNK_ bir yüzeye koymanız gerekir .
yani onları bir yüzeye dökerseniz buraya _UNK_ başlarlar ve atom mikroskobu ile bunların resimlerini çekebilirsiniz .
mikroskobun üzerinde ufak bir iğne mevcut , pikap iğnesi gibi yüzeyde ileri geri gidiyor ve tümsek ve çukurlarda _UNK_ yüzeyin yüksekliğini algılıyor .
dna origamisini hissedebiliyor .
burada atom mikroskobu çalışıyor ve biraz düzensiz olduğunu görebilirsiniz .
yakınlaştırırsanız , göreceksiniz , bazılarının çenesi bozuk , kafalarının üstünde bazılarının burnu yumruk yemiş gibi , ama genelde iyi görünüyorlar .
hatta iyice yakınlaştırırsanız alttaki ufak halkayı bile görebilirsiniz , bir nano - keçi - sakalı .
muhteşem olan şey şu , bunu herkes yapabilir .
bunu yaptıktan bir yıl kadar sonra postayla bu geldi , kendiliğinden .
bunun ne olduğunu bilen var mı ? ne bu ?
çin , değil mi ?
olan şu , çin'deki bir doktora öğrencisi _UNK_ _UNK_ , süper bir iş yapmış .
tüm yazılımı da kendisi yapmış ve bu dna origamisini tasarlamış ve oluşturmuş , çin'in çok güzel bir haritası , hatta taiwan bile var , üzerinde dünyanın en kısa ipini de görebiliyorsunuz değil mi ?
yani , bu epey iyi çalışıyor şekiller yapabildiğiniz gibi şablonlar da yapabilirsiniz
amerika haritası yapabilirsiniz , ya da dna kullanarak dna yazabilirsiniz .
ama bunun en güzel tarafı -- aslında bu nano - sanat gibi bir şey , ama şu var ki , nano - sanat nano - devreler yapmak için gereken şey aslında .
zımbaların üzerine ufak devre bileşenleri koyabilirsiniz , mesela bir ampul ya da anahtar ,
kendi kendine _UNK_ bekleyin , sonuçta elinizde bir tür devre olacaktır .
daha sonra dna'yı _UNK_ , elinizde devre kalacaktır .
_UNK_ bir grup meslektaşımın yaptığı da bu .
bir dna origamisi aldılar , bazi karbon nano - tüpler düzenlediler , _UNK_ bir anahtar yaptılar , burada görüyorsunuz , kablolanmış , test ettiler ve gösterdiler ki bu gerçekten de bir anahtar .
evet , bu tek bir anahtar , ve bir bilgisayar yapmak için bundan yarım milyar lazım , yani _UNK_ yolumuz epey uzun .
ama çok umut verici çünkü origami yöntemi normal bir bilgisayara göre onda - bir büyüklüğündeki parçaları bir araya getirmeye yarıyor .
yani küçük bilgisayarlar yapmak için çok umut verici .
şimdi , bu derleyiciye geri dönmek istiyorum .
dna origamisi ve _UNK_ gerçekten çalıştığının kanıtı ,
yani bilgisayarın içindeki birşey ile başlıyorsunuz .
bu programın üst - seviye tanımlamasını elde ediyorsunuz , _UNK_ üst - seviye _UNK_ .
bunu moleküller kullanarak _UNK_ , bir sentezleyiciye gönderebilir ve çalışan birşey yaratabilirsiniz .
bir firma benim yazdığım aslında biraz da çirkin olan koddan çok daha güzel bir program yaptı , bu program , bize bu tasarımları bilgisayar destekli görsel bir şekilde yapma imkanı sağlıyor .
şimdi şöyle diyebilirsiniz , tamam , bu dna origami olayı neden hikayenin sonu değil ?
elinizde moleküler derleyici var , ne isterseniz yapabilirsiniz .
gerçek şu ki , ölçeklenebilir değil .
yani eğer orgiami tekniğini kullanarak insan dna'yı yapmak isterseniz , sorun şu ki , çok uzun bir _UNK_ ihtiyacınız var , iplikçik 10 trilyon baz uzunluğunda olmalı .
yani ü ç ışık yılı değerinde dna , bu nedenle bunu yapamayacağız .
yerine , bir başka teknolojiye geçeceğiz buna " kendinden kurulan algoritmik karolar " deniyor .
bunu başlatan erik _UNK_ , yaptığı şu , içinde dna origamisinin yüzde bir boyutunda karolar var .
eğer yakınlaşırsanız , sadece dört dna _UNK_ göreceksiniz üzerlerinde de kendi ufak tek sarmallı parçacıkları var , uygun olan diğer karolara _UNK_ .
bu karoları kare _UNK_ çizmeyi seviyoruz .
eğer yapışkan uç noktalarına , uçtaki dna parçacıklarına bakarsanız , bir nevi _UNK_ . tahtasına benzediklerini görürsünüz .
bu karolar , kompleks , kendi kendine düzenlenen bir satranç tahtası oluşturuyorlar .
eğer fark etmediyseniz , bunun önemi bu karoların bir nevi moleküler program olması ve çıktı olarak şablon verebilmeleri .
ve geçekten inanılmaz olan nokta şu ki herhangi bir bilgisayar programı bu karo programlarından herhangi birine tercüme edilebilir -- özellikle de sayma .
yani , bir araya geldiklerinde bir satranç tahtası değil de ikilik düzende sayı sayan bir yapı oluşturabilirler .
yani ikilik düzende beş , altı ve _UNK_ okuyabilirsiniz
bu hesaplamaları doğru bir şekilde başlatmak için bir nevi _UNK_ , bir tohuma ihtiyacınız var .
bunun için dna origamisini kullanabilirsiniz .
dna origamisinin sağ tarafında 32 rakamını _UNK_ bu karoları eklediğinizde hesaplamaya başlayacak , _UNK_ gelecek ve _UNK_ _UNK_ .
bu şekilde , bir nevi , moleküler bir programın zamanı gelince durmasını sağlayan bir yol bulmuş olduk .
ne zaman çoğalmayı bırakacağını biliyor çünkü sayı sayabiliyor .
ne kadar büyük olduğunu biliyor .
bu , en başta sorduğum soruyu bir şekilde yanıtlıyor .
ama bunu bebeklerin nasıl yaptığını tam söylemiyor .
artık , bu sayı saymayı kullanarak çok ama çok daha büyük şeyler elde edebiliriz . bunu dna _UNK_ yapamaz .
i̇şte dna origamisi , çunu yapabiliriz , dna origamisinin dört bir yanına 32 yazabiliriz ve sulama cihazımızı kullanarak karoları _UNK_ ve bu şekilde bir kare oluşturacak yeni karolar oluşturabiliriz .
sayaç bir nevi şablon görevi görüyor ortadaki bu karenin içini doldurmaya yarıyor .
yaptığımız şey şu , dna origamisi ve karoları birleştirerek , tek başına dna origaminin yapamayacağı kadar büyük bir şey yapmayı başardık .
bunun güzel yanı , tekrar programlanabilir olması .
i̇kilik _UNK_ birkaç dna kodunu değiştirebilirsiniz , ve 96 yerine 32 elde edersiniz .
eğer bunu aynı _UNK_ _UNK_ yapacak olursanız _UNK_ elde edeceğiniz kare ü ç kat daha büyük olacaktır .
bu durum , size daha önce bahsettiğim gelişme ile ilgili konuyu bir kez daha gösteriyor .
elinizde çok hassas bir bilgisayar programı var , küçük değişiklikler -- ufacık , minicik mutasyonlar -- bir boy kare üreten bir şeyi alabilir ve onu olduğundan çok ama çok daha büyük bir hale getirebilir .
bu tip şeyleri üretmek ve hesaplamak için sayı saymak , ve bu tip geliştirici süreçler kullanmak aynı zamanda craig venter'in sorusu ile da alakalı .
kendinize sorabilirsiniz , bahsedilen büyüklükte bir kareyi kurmak için kaç dna iplikçiği gerekiyor ?
10 , 100 , ya da 1,000 büyüklüğünde bir kare yapmak istersek eğer tek başına dna origamisi _UNK_ isteiğimiz sayının karesi kadar _UNK_ _UNK_ kullanmamız lazım . yani 100 , 10.000 ya da bir milyon dna iplikçiği .
bu altından _UNK_ bir şey değil .
ama eğer biraz hesaplama yaparsak -- orgiami kullanır ve bu buna ilaveten sayı sayacak kareler de eklersek -- 100 , 200 ya da 300 dna iplikçiği kullanmamız yeterli olacaktır .
yani eğer sayma tekniğini kullanırsak , çok az hesaplama yapsak bile kullanmamız _UNK_ dna iplikçik sayısını anlamlı ölçüde azaltabiliriz .
yani hesaplama , birşey üretmeye çalışıyorsanız ihtiyacınız olan molekül sayısını azaltmak için , yaratmaya çalıştığınız genomun boyutunu küçültmek için çok önemli bir yöntem .
son olarak , daha önce bahsettiğim bilgisayarların bilgisayar üretmesi ile ilgili olan çılgın fikre geri dönmek istiyorum .
eğer origami kullanarak yarattığınız kareye ucundan çıkan _UNK_ bakacak olursanız bu yapı aynen hafıza yapmak için ihtiyacınız olan yapının birebir aynısıdır .
bu karolara zımba _UNK_ yerine bazı kablolar ve anahtarlar _UNK_ olursanız kendi kendilerine _UNK_ bir tür karmaşık devreler oluşturacaklardır -- bu hafızada olması gereken _UNK_ devreleri oluştururlar .
yani aslında , biraz hesaplama ile gerçekten de oldukça karmaşık bir devre yapabilirsiniz .
bu moleküler bir bilgisayarın , _UNK_ bir bilgisayar yapması .
şimdi bana , " henüz bu noktaya ulaşabildik mi ? " diye sorabilirsiniz .
deneysel olarak , geçen yıl yaptığımız şey bu .
bu bir dna origami _UNK_ , ve burada ondan bazı karolar ürüyor .
nasıl _UNK_ _UNK_ .
bir , iki , ü ç , dört , beş , altı , dokuz , 10 , 11 , 12 , 17 .
arada hatalar var , ama en azından büyüterek saymayı biliyor .
bu fikir ilk defa dokuz yıl önce aklımıza geldi , bu tip şeyleri yapabilmek için gereken zaman dilimi de aşağı yukarı bu kadar , bence büyük bir aşama kaydettik .
bu hataları nasıl düzeltmemiz gerektiği konusunda bazı fikirlerimiz var .
ve sanırım önümüzdeki beş ila 10 yıl içinde bahsettiğim tipteki karelerden yapıyor ve hatta belki de bahsettiğim kendi kendine kurulan _UNK_ bazılarını _UNK_ olacağız .
peki şimdi , bu konuşmadan almak istediğiniz ana fikir ne ?
şunu _UNK_ istiyorum yaşayan karmaşık ve çeşitli canlıların oluşumunda hayat da hesaplama kullanıyor .
yaptığı hesaplamalar , moleküler hesaplamalar , feynman'ın da dediği gibi , bunu anlayabilmek ve daha iyi kavrayabilmek için , bunu anlamamıza yarayan bir şey yaratıyor olmalıyız .
bu nedenle moleküller kullanacağız ve bunu tekrar tasarlayarak _UNK_ en baştan yeniden yaratacağız , dna'yı doğanın hiç _UNK_ şekillerde kullanarak yapacağız bunu . dna _UNK_ kullanarak ve dna _UNK_ bu algoritmik kendinden - kurulan sistemler için bir tohum olarak kullanarak .
biliyorsunuz , bunların hepsi müthiş şeyler , ama sizin bu konuşmadan edindiğiniz fikrin bu büyük soruların bir kısmını _UNK_ umut ederim , bu _UNK_ programlama , sadece cihazlar yapmakla ilgili _UNK_ değil .
sadece kendinden - kurulan cep telefonları ya da devreler üretmekle ilgili birşey de değil .
gerçekte , aslında bilgisayar bilimi aracılığıyla büyük sorulara yeni bir ışık altında bakabilmek , bu büyük soruların yeni _UNK_ sorabilmek ve biyolojinin böyle müthiş şeyleri nasıl yapabildiğini anlamaya çalışmakla ilgili . teşekkürler .
